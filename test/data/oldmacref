/* This program is free software: you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation, either version 3 of the License, or   (at your option) any later version.   endlines : Mathias Dolidon / 2014 */#include "endlines.h"#include <string.h>// ENUMS AND CONSTANTS ARE DEFINED IN ENDLINES.HChar *convention_display_names[3]; voidsetup_display_names() {    convention_display_names[CR] = "Legacy Mac (CR)";    convention_display_names[LF] = "Unix (LF)";    convention_display_names[CRLF] = "Windows (CR-LF)";}typedef struct {    char name[10];    convention_t convention;}command_line_to_convention_t;#define CL_NAMES_COUNT 11command_line_to_convention_t cl_names[CL_NAMES_COUNT] = {    {.name="lf",      .convention=LF},    {.name="unix",    .convention=LF},    {.name="linux",   .convention=LF},    {.name="crlf",    .convention=CRLF},    {.name="win",     .convention=CRLF},    {.name="windows", .convention=CRLF},    {.name="dos",     .convention=CRLF},    {.name="msdos",   .convention=CRLF},    {.name="osx",     .convention=CRLF},    {.name="cr",      .convention=CR},    {.name="oldmac",  .convention=CR}};voiddisplay_help_and_quit() {    fprintf(stderr, "\n--- Convert between line ending conventions. ---\n");    fprintf(stderr, "Use : endlines CONVENTION [FILES]\n\n");    fprintf(stderr, "Input convention is determined automatically.\n");    fprintf(stderr, "CONVENTION expresses the wished output convention.\n");    fprintf(stderr, "CONVENTION can be : ");    for(int i=0; i<CL_NAMES_COUNT; i++) {        fprintf(stderr, "%s ", cl_names[i].name);    }    fprintf(stderr, "\nIf no files are specified, endlines converts from stdin to stdout.\n\n");    fprintf(stderr, "    Example :\n");    fprintf(stderr, "    endlines unix `find . -name \"*.html\"`\n\n");    exit(1);}convention_tread_convention_from_args(int argc, char**argv) {    for(int i=0; i<CL_NAMES_COUNT; i++) {        if(!strcmp(cl_names[i].name, argv[1])) {            return cl_names[i].convention;        }    }    fprintf(stderr, "endlines : unknown line end convention : %s\n", argv[1]);    display_help_and_quit();    return -1; // This is only to silence compiler warnings.}voidconvert_file(char *file_name, convention_t convention) {    FILE * in = fopen(file_name, "rb");    if(in == NULL) {        fprintf(stderr, "endlines : could not read %s\n", file_name);        return;    }    FILE * out = fopen(TMP_FILE_NAME, "wb");    if(out == NULL) {        fprintf(stderr, "endlines : could not create temporary file %s\n", TMP_FILE_NAME);        fclose(in);        return;    }    convert(in, out, convention);        fclose(in);    fclose(out);    int remove_status = remove(file_name);    if(remove_status) {        fprintf(stderr, "endlines : can't write over %s\n", file_name);        return;    }    rename(TMP_FILE_NAME, file_name);}intmain(int argc, char**argv) {    if(argc<2) {        display_help_and_quit();    }    setup_display_names();    convention_t convention = read_convention_from_args(argc, argv);    bool files = argc>2;    if(files) {        fprintf(stderr, "Converting %i file%s to %s\n", argc-2, argc>3?"s":"", convention_display_names[convention]);        for(int i=2; i<argc; i++) {            convert_file(argv[i], convention);        }    }    else {        convert(stdin, stdout, convention);        fprintf(stderr, "Converting stdin to %s\n", convention_display_names[convention]);    }    return 0;}